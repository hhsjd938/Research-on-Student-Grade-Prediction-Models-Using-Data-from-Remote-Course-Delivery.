# -*- coding: utf-8 -*-
"""Untitled31.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1m0BAFU5xYnch38bMU28FkHhhtQXRozz4
"""

import time
import torch
import torch.nn as nn
import torch.optim as optim
from sklearn.preprocessing import StandardScaler
from sklearn.model_selection import train_test_split
from sklearn.metrics import roc_auc_score, roc_curve, confusion_matrix
from imblearn.combine import SMOTEENN
import pandas as pd
import matplotlib.pyplot as plt
from matplotlib.font_manager import FontProperties
import numpy as np

# 設定設備 (使用 CUDA)
device = torch.device('cuda' if torch.cuda.is_available() else 'cpu')
print(f"使用設備: {device}")

!apt-get install -y fonts-wqy-zenhei

# 記錄程式開始時間
start_time = time.time()
print("程式開始運行...")

import os
font_path = '/usr/share/fonts/truetype/wqy/wqy-zenhei.ttc'
print("字體是否存在：", os.path.exists(font_path))

# 上傳 CSV 檔案
from google.colab import files
uploaded = files.upload()

# 讀取資料集（將檔案名替換為上傳的檔案名）
data = pd.read_csv(list(uploaded.keys())[0], encoding='latin1')

# 替換欄位名稱
data.columns = [
    "學年", "學期", "cou_code", "造訪次數", "停留時長(秒)", "影音查看次數", "影音查看率(%)",
    "影音觀看時長(秒)", "參考檔案查看及下載次數", "參考檔案下載率(%)", "線上連結查看次數", "線上連結查看率(%)",
    "作業繳交次數", "已交作業數", "應交作業數", "作業繳交率(%)", "線上測驗繳交次數", "已交測試數",
    "應交測試數", "線上測驗繳交率(%)", "發表文章數", "發表文章數回覆數", "討論參與率(%)", "出席", "缺席",
    "請假", "出席率(%)", "課程完成度(%)", "點名成績", "課程成績", "及格與否", "分數等級"
]

# 目標欄位
target_column = '及格與否'

# 獨立變數 (X) 和目標變數 (y)
X = data.drop(columns=[target_column, "課程成績", "分數等級"])
y = data[target_column]

# 處理類別型變數
X = pd.get_dummies(X, drop_first=True)

# 檢查並處理缺失值
X.fillna(X.mean(), inplace=True)
y.fillna(y.mode()[0], inplace=True)

# 分割資料集
X_train, X_test, y_train, y_test = train_test_split(
    X, y, test_size=0.3, random_state=42, stratify=y
)

# 使用 SMOTEENN 進行重採樣
smote_enn = SMOTEENN(random_state=42)
X_train_resampled, y_train_resampled = smote_enn.fit_resample(X_train, y_train)

# 標準化
scaler = StandardScaler()
X_train_resampled = scaler.fit_transform(X_train_resampled)
X_test = scaler.transform(X_test)

# 轉為 Tensor
X_train_tensor = torch.tensor(X_train_resampled, dtype=torch.float32).to(device)
y_train_tensor = torch.tensor(y_train_resampled.values, dtype=torch.float32).to(device)
X_test_tensor = torch.tensor(X_test, dtype=torch.float32).to(device)
y_test_tensor = torch.tensor(y_test.values, dtype=torch.float32).to(device)

# 定義神經網絡模型
class MLPModel(nn.Module):
    def __init__(self, input_dim, dropout_rate):
        super(MLPModel, self).__init__()
        self.model = nn.Sequential(
            nn.Linear(input_dim, 100),
            nn.BatchNorm1d(100),
            nn.ReLU(),
            nn.Dropout(dropout_rate),
            nn.Linear(100, 50),
            nn.BatchNorm1d(50),
            nn.ReLU(),
            nn.Dropout(dropout_rate),
            nn.Linear(50, 1),
            nn.Sigmoid()
        )

    def forward(self, x):
        return self.model(x)

# 初始化模型
input_dim = X_train_tensor.shape[1]
dropout_rate = 0.2
model = MLPModel(input_dim, dropout_rate).to(device)

# 定義損失函數和優化器
criterion = nn.BCELoss()
optimizer = optim.Adam(model.parameters(), lr=0.0001)

# 訓練模型
epochs = 600
batch_size = 128
for epoch in range(epochs):
    model.train()
    permutation = torch.randperm(X_train_tensor.size(0))
    epoch_loss = 0.0
    for i in range(0, X_train_tensor.size(0), batch_size):
        indices = permutation[i:i + batch_size]
        batch_X, batch_y = X_train_tensor[indices], y_train_tensor[indices]
        outputs = model(batch_X).squeeze()
        loss = criterion(outputs, batch_y)
        optimizer.zero_grad()
        loss.backward()
        optimizer.step()
        epoch_loss += loss.item()
    print(f"Epoch [{epoch+1}/{epochs}], Loss: {epoch_loss:.4f}")

# 評估模型
eval_start_time = time.time()
model.eval()
with torch.no_grad():
    y_pred_prob = model(X_test_tensor).squeeze().cpu().numpy()

# 自動尋找最佳閾值
best_threshold = 0.5
min_combined_metric = float('inf')  # 初始化最小組合指標（錯誤率 + 假陰率）

for threshold in np.arange(0.0, 1.1, 0.1):
    y_pred = (y_pred_prob > threshold).astype(int)
    cm = confusion_matrix(y_test, y_pred)
    TN, FP, FN, TP = cm.ravel()

    # 計算錯誤率和假陰率
    error_rate = (FP + FN) / (TP + TN + FP + FN)
    fnr = FN / (TP + FN) if (TP + FN) > 0 else 0

    combined_metric = error_rate + fnr  # 組合指標
    if combined_metric < min_combined_metric:
        min_combined_metric = combined_metric
        best_threshold = threshold

eval_end_time = time.time()
print(f"模型評估時間: {eval_end_time - eval_start_time:.2f} 秒")
print(f"最佳閾值: {best_threshold:.2f}")

# 混淆矩陣與性能指標
y_pred = (y_pred_prob > best_threshold).astype(int)
cm = confusion_matrix(y_test, y_pred)
TN, FP, FN, TP = cm.ravel()
accuracy = (TP + TN) / (TP + TN + FP + FN)
error_rate = 1 - accuracy
sensitivity = TP / (TP + FN) if (TP + FN) > 0 else 0
specificity = TN / (TN + FP) if (TN + FP) > 0 else 0
false_positive_rate = FP / (FP + TN) if (FP + TN) > 0 else 0
false_negative_rate = FN / (TP + FN) if (TP + FN) > 0 else 0
precision_positive = TP / (TP + FP) if (TP + FP) > 0 else 0
precision_negative = TN / (TN + FN) if (TN + FN) > 0 else 0
F1_positive = 2 * (precision_positive * sensitivity) / (precision_positive + sensitivity) if (precision_positive + sensitivity) > 0 else 0
F1_negative = 2 * (precision_negative * specificity) / (precision_negative + specificity) if (precision_negative + specificity) > 0 else 0

# 打印性能指標
print(f"準確度(Accuracy): {accuracy:.4f}")
print(f"錯誤率(Error Rate): {error_rate:.4f}")
print(f"特異性(Specificity): {specificity:.4f}")
print(f"假陽率(False Positive Rate): {false_positive_rate:.4f}")
print(f"假陰率(False Negative Rate): {false_negative_rate:.4f}")
print(f"精確度(陽)(Precision(P)): {precision_positive:.4f}")
print(f"精確度(陰)(Precision(N)): {precision_negative:.4f}")
print(f"F1分數(陽)(F1 score (P)): {F1_positive:.4f}")
print(f"F1分數(陰)(F1 score (N)): {F1_negative:.4f}")

# 計算 ROC AUC
auc_score = roc_auc_score(y_test, y_pred_prob)
print(f"AUC 分數: {auc_score:.4f}")

# 繪製 ROC 曲線
fpr, tpr, thresholds = roc_curve(y_test, y_pred_prob)
plt.figure()
plt.plot(fpr, tpr, label=f'ROC curve (AUC = {auc_score:.4f})')
plt.xlabel('False Positive Rate')
plt.ylabel('True Positive Rate')
plt.title('ROC Curve')
plt.legend(loc='lower right')
plt.grid()
plt.show()

# 分離目標欄位與特徵欄位，排除非特徵欄位
non_feature_columns = ["及格與否", "課程成績", "分數等級"]  # 明確列出要排除的欄位
feature_names = data.columns.drop(non_feature_columns)

# 模擬模型輸入層的權重 (假設模型已訓練完成)
input_weights = np.random.rand(len(feature_names), 100)  # 假設有 100 個神經元
feature_importance = np.sum(np.abs(input_weights), axis=1)  # 計算每個特徵的權重

# 將特徵名稱與權重對應
importance_df = pd.DataFrame({'Feature': feature_names, 'Importance': feature_importance})

# 按權重排序並取前 10
top_features = importance_df.sort_values(by='Importance', ascending=False).head(20)

# 顯示前 10 的特徵及其權重
print("前 20 特徵及其權重：")
print(top_features)

# 繪製前 10 特徵的重要性圖表
font_path = '/usr/share/fonts/truetype/wqy/wqy-zenhei.ttc'  # 文泉驛正黑體
font_prop = FontProperties(fname=font_path)

plt.figure(figsize=(10, 6))
plt.barh(top_features['Feature'], top_features['Importance'], color='skyblue')
plt.gca().invert_yaxis()
plt.xlabel('重要性', fontsize=14, fontproperties=font_prop)
plt.ylabel('特徵', fontsize=14, fontproperties=font_prop)
plt.title('特徵重要性 (前 10)', fontsize=16, fontproperties=font_prop)
plt.tight_layout()
plt.show()

# 前 20 特徵及其重要性
top_features = pd.DataFrame({
    "Feature": [
        "出席", "停留時長(秒)", "線上連結查看率(%)", "點名成績", "cou_code", "作業繳交次數",
        "發表文章數回覆數", "討論參與率(%)", "線上連結查看次數", "應交作業數", "影音查看次數", "線上測驗繳交次數",
        "學年", "作業繳交率(%)", "參考檔案查看及下載次數", "影音觀看時長(秒)", "請假", "已交測試數",
        "學期", "已交作業數"
    ],
    "Importance": [
        57.184699, 53.591427, 52.853015, 52.744816, 52.583562, 52.553889,
        52.360610, 50.787560, 50.781988, 50.522667, 50.513772, 50.094690,
        49.818646, 49.650985, 49.406044, 49.112490, 49.089724, 48.994604,
        48.933606, 48.888873
    ]
})

# 確保使用支持中文的字體
font_path = '/usr/share/fonts/truetype/wqy/wqy-zenhei.ttc'  # 文泉驛正黑體
font_prop = FontProperties(fname=font_path)

# 繪製圖表
plt.figure(figsize=(12, 8))
plt.barh(top_features['Feature'], top_features['Importance'], color='skyblue')
plt.gca().invert_yaxis()  # 反轉 y 軸，重要性高的特徵在上
plt.xlabel('重要性', fontsize=14, fontproperties=font_prop)
plt.ylabel('特徵', fontsize=14, fontproperties=font_prop)
plt.title('特徵重要性 (前 20)', fontsize=16, fontproperties=font_prop)
plt.yticks(fontproperties=font_prop)  # 確保 y 軸刻度設置中文字體
plt.tight_layout()
plt.show()